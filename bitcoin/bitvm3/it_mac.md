**Step One**

Mask real bit values of some wire $\alpha$:
$$
\hat{x} = x \oplus \lambda_\alpha
$$

Regarding the mask bit $\lambda_\alpha$:
- one mask bit per wire
- it is randomly determined in setup phase
- it is unknown to evaluator

<br />

**Step Two**

Split mask bit $\lambda_\alpha$ into two partial parts:
$$
\lambda_\alpha = r_\alpha \oplus s_\alpha
$$
where partial mask bits $r_\alpha$ and $s_\alpha$ are owned by garbler and evaluator separately.

<br />

**Step Three**

Authenticate the partial bits: 
$$
M[r_\alpha] = K[r_\alpha] \oplus r_\alpha \cdot \Delta_B \\
M[s_\alpha] = K[s_\alpha] \oplus s_\alpha \cdot \Delta_A \\
$$
where:
1. $M[r_\alpha], M[s_\alpha]$ are the **MAC** tags generated by $P_B$ and $P_A$, and sends them to counter-party respectively.
2. $\Delta_A, \Delta_B$ are global private *offset*s hold by each party, note that they are not relevant with some specific garble circuit. 
3. $K[r_\alpha], K[s_\alpha]$ are randomly generated tied with some specific wire by both parties.

<br />

**MAC** Preprocessing:
1. Party $P_B$ compute **MAC** tag $M[r_\alpha]$ with $(K[r_\alpha], \Delta_B)$, in the meantime, party $P_B$ should also know the partial mask bit $r_\alpha$ in advance. And sends it to party $P_A$.
2. Party $P_A$ compute **MAC** tag $M[s_\alpha]$ with $(K[s_\alpha], \Delta_A)$, and sends it to party $P_B$.
3. As a result, party $P_A$ holds $(r_\alpha, M[r_\alpha], K[s_\alpha], \Delta_A)$, and party $P_B$ holds $(s_\alpha, M[s_\alpha], K[r_\alpha], \Delta_B)$.

<br />

## Setup Phase

Party $P_A$ (garbler) has to generate all Party $P_A$'s storage after setup phase should be like:
```json
{
    "wire_alpha": {
        "l0_alpha": "k-bit label",   # wire zero-label
    }
    "wire_beta": {
        "l0_beta": "k-bit label",   # wire zero-label
    }
    "wire_gamma": {
        "l0_gamma": "k-bit label",   # wire zero-label
    }
    // other wires ...
}
```

<br />

## Preprocessing Phase

<br />

## Evaluation Phase

<br />

Party $P_A$'s storage should be like:
```json
{
  "global_key": Δ_A           # Secret global MAC key
  // for wire alpha
  "wire_alpha": {
    "l_alpha": "k-bit label",     # wire zero-label
    "r_alpha": 0/1,               # Share of λ_α
    "M_r_alpha": "κ-bit MAC",     # MAC from P_B
    "K_s_alpha": "κ-bit key"      # Key to verify P_B's share
  },
  // for wire beta
  "wire_beta": {
    "l_beta": "k-bit label",     
    "r_beta": 0/1,
    "M_r_beta": "k-bit MAC",
    "K_s_beta": "k-bit key"
  },
  // for wire gamma
  "wire_gamma": {
    "l_gamma": "k-bit label",
    "r_gamma": 0/1,
    "M_r_gamma": "k-bit MAC",
    "K_s_gamma": "k-bit key"
  },
  // ...
}
```

Party $P_B$'s storage should be like:
```json
{
  "global_key": Δ_B           # Secret global MAC key
  // for wire alpha
  "wire_alpha": {
    "s_alpha": 0/1,               # Share of λ_α
    "M_s_alpha": "κ-bit MAC",     # MAC from P_A
    "K_r_alpha": "κ-bit key"      # Key to verify P_A's share
  },
  // for wire beta
  "wire_beta": {
    "s_beta": 0/1,
    "M_s_beta": "k-bit MAC",
    "K_r_beta": "k-bit key"
  },
  // for wire gamma
  "wire_gamma": {
    "s_gamma": 0/1,
    "M_s_gamma": "k-bit MAC",
    "K_r_gamma": "k-bit key"
  },
  // ...
}
```



Assuming a garble circuit $C$ has $N$ wires in total, party $P_A$ (garbler) holds:
1. global secret *offset* $\Delta_A$, it is independent with some specific garble circuit $C$.
2. generate $N$ mask bit values 
use crate::AsInteger;
use crate::Modulos;
use crate::integer_quadratic::{BIAS, IntegerBaseField, IntegerQuadraticField, MU};
use core::ops::{Add, Div, Mul, Neg, Sub};

pub type TauNAFw = Vec<Tau>;

#[derive(Copy, Clone, Debug)]
struct LucasSequence<const U0: IntegerBaseField = 0, const U1: IntegerBaseField = 1> {
    u0: IntegerBaseField,
    u1: IntegerBaseField,
}

impl<const U0: IntegerBaseField, const U1: IntegerBaseField> LucasSequence<U0, U1> {
    const fn new() -> Self {
        Self { u0: U0, u1: U1 }
    }

    // refer to "Handbook of Elliptic and Hyperelliptic Curve Cryptography", equation 15.4
    pub fn next(&self) -> Self {
        Self {
            u0: self.u1,
            u1: MU * self.u1 - BIAS * self.u0,
        }
    }
}

impl<const U0: IntegerBaseField, const U1: IntegerBaseField> AsInteger for LucasSequence<U0, U1> {
    type Output = IntegerQuadraticField;
    fn as_integer(&self) -> Self::Output {
        IntegerQuadraticField::new(-BIAS * self.u0, self.u1)
    }
}

type TauLucasSequence = LucasSequence<0, 1>;

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct Tau(pub IntegerQuadraticField);

impl Default for Tau {
    fn default() -> Self {
        Self(TauLucasSequence::new().as_integer())
    }
}

impl Add for Tau {
    type Output = Self;
    fn add(self, other: Self) -> Self::Output {
        Self(self.0 + other.0)
    }
}

impl Sub for Tau {
    type Output = Self;
    fn sub(self, other: Self) -> Self::Output {
        Self(self.0 - other.0)
    }
}

impl Mul for Tau {
    type Output = Self;
    fn mul(self, other: Self) -> Self::Output {
        Self(self.0 * other.0)
    }
}

impl Div for Tau {
    type Output = (Self, Self);
    fn div(self, other: Self) -> Self::Output {
        let (q, r) = self.0 / other.0;
        (Self(q), Self(r))
    }
}

impl Neg for Tau {
    type Output = Self;
    fn neg(self) -> Self::Output {
        Self(IntegerQuadraticField::new(-self.0.a0, -self.0.a1))
    }
}

impl From<IntegerBaseField> for Tau {
    fn from(value: IntegerBaseField) -> Self {
        Self(IntegerQuadraticField::new(value, 0))
    }
}

impl Tau {
    pub fn is_odd(&self) -> bool {
        self.0.a0.modulos(2) == 1
    }

    pub fn is_canonical(&self) -> bool {
        ((self.0.a0.abs() == 1) || (self.0.a0.abs() == 0))
            && ((self.0.a1.abs() == 1) || (self.0.a1.abs() == 0))
    }

    pub fn reduce(&self, modulus: &Self) -> Self {
        let (_, r) = self.clone() / modulus.clone();
        r
    }

    pub fn new(n0: IntegerBaseField, n1: IntegerBaseField) -> Self {
        Self(IntegerQuadraticField::new(n0, n1))
    }

    pub fn zero() -> Self {
        Self(IntegerQuadraticField::zero())
    }

    pub fn one() -> Self {
        Self(IntegerQuadraticField::one())
    }

    pub fn trace(&self) -> IntegerBaseField {
        MU
    }

    pub fn determint(&self) -> IntegerBaseField {
        BIAS
    }

    pub fn value(&self) -> &IntegerQuadraticField {
        &self.0
    }

    // \tau^d = U_d * \tau - U_{d - 1} * BIAS
    pub fn pow(&self, d: usize) -> Self {
        if d == 0 {
            return Self(IntegerQuadraticField::one());
        }
        if d == 1 {
            return *self;
        }
        let mut result = TauLucasSequence::new();
        for _ in 1..d {
            result = result.next();
        }

        Self(result.as_integer())
    }

    // hw is approximate of \tau mod 2^k
    // refer to "Handbook of Elliptic and Hyperelliptic Curve Cryptography" page 363
    pub fn hw(w: usize) -> IntegerBaseField {
        let mut l = TauLucasSequence::new();
        for _ in 0..w - 1 {
            l = l.next();
        }
        let uk_inv = l.u1.inv_mod_pow_k(w);
        (2 * l.u0 * uk_inv).modulos(1 << w)
    }

    // refer to "Handbook of Elliptic and Hyperelliptic Curve Cryptography" page 363
    pub fn precomputed_table(w: usize) -> (Vec<Self>, Vec<Self>) {
        let tau_w = Tau::default().pow(w);
        let mut rem_u = vec![];
        // let mut alpha_u = vec![];
        for u in (1..(1 << w)).step_by(2) {
            let rem = Tau::from(u).reduce(&tau_w);
            rem_u.push(rem);
        }
        todo!()
    }

    // convert to \tau-NAF representation
    // refer to "Handbook of Elliptic and Hyperelliptic Curve Cryptography", Algorithm 15.6
    pub fn to_naf(&self) -> Vec<i8> {
        let mut s = vec![];
        let (mut n0, mut n1) = (self.value().a0, self.value().a1);
        let mut r: i8;
        while n0.abs() + n1.abs() != 0 {
            if n0.modulos(2) == 1 {
                r = (2 - (n0 - 2 * n1).modulos(4)) as i8;
                n0 -= r as i64;
            } else {
                r = 0;
            }
            s.push(r);
            (n0, n1) = (n1 + n0 / 2, -n0 / 2);
        }
        s
    }

    // refer to "Handbook of Elliptic and Hyperelliptic Curve Cryptography", Algorithm 15.17
    pub fn to_naf_w(&self, w: usize) -> TauNAFw {
        // precomputed tables
        let alpha_table = vec![Tau::default(); 1 << (w - 1)];
        let beta_table = vec![0; 1 << (w - 1)];
        let gamma_table = vec![0; 1 << (w - 1)];
        let hw = Tau::hw(w);
        let base_modulus = 1 << w;
        let mut result = vec![];
        let mut eta = self.clone();
        let mut r = Tau::zero();
        while eta.value().a0.abs() + eta.value().a1.abs() != 0 {
            if eta.value().a0.modulos(2) == 1 {
                // hw is approximate of tau mod 2^w
                let u = (eta.value().a0 + eta.value().a1 * hw) % base_modulus;
                let ui = u.abs() as usize;
                let delta = Tau::new(beta_table[ui], gamma_table[ui]);
                // after removing alpha_table[ui], eta is divisible by tau
                (eta, r) = if u > 0 {
                    (eta - delta, alpha_table[ui])
                } else {
                    (eta + delta, -alpha_table[ui])
                };
            } else {
                r = Tau::zero();
            }
            result.push(r);
            let (quo, rem) = eta / Tau::default();
            assert_eq!(rem, Tau::zero());
            eta = quo;
        }
        result
    }
}

pub struct CanonicalTau<const W: usize>([IntegerBaseField; W]);

impl<const W: usize> From<Tau> for CanonicalTau<W> {
    fn from(tau: Tau) -> Self {
        if tau.is_canonical() {
            let mut arr = [0; W];
            arr[0] = tau.0.a0;
            arr[1] = tau.0.a1;
            Self(arr)
        } else {
            let mut tau_mut = tau.clone();
            while tau_mut.is_canonical() == false {}
        }
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_tau_pow() {
        let tau = Tau::default();
        assert_eq!(
            *tau.pow(2).value(),
            IntegerQuadraticField::new(-BIAS * 1, MU)
        )
    }

    #[test]
    fn test_delta() {
        let tau = Tau::default();
        let nominator = *tau.pow(11).value() - IntegerQuadraticField::one();
        let denominator = *tau.value() - IntegerQuadraticField::one();
        let (quotient, remainder) = nominator / denominator;
        assert_eq!(quotient, IntegerQuadraticField::new(23, -22));
        assert_eq!(remainder, IntegerQuadraticField::zero());
    }

    // refer to "Handbook of Elliptic and Hyperelliptic Curve Cryptography", Example 15.8
    #[test]
    fn test_to_tau_naf() {
        let scalar = Tau(IntegerQuadraticField::new(409, 0));
        let tau_naf = scalar.to_naf();
        let expected_tau_naf = vec![1, 0, 0, 1, 0, 0, 1, 0, -1, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1];
        assert_eq!(tau_naf, expected_tau_naf);
    }

    // refer to "Handbook of Elliptic and Hyperelliptic Curve Cryptography" page 363
    // ring Z[\tau] / \tau^k is isomorphic to Z / 2^k, exists a map: \varphi(\tau) = h_k
    #[test]
    fn test_hw() {
        let k = 4;
        let base_modulus = 1 << k;
        // hk = 2 * U_{k - 1} / U_k mod 2^k
        let mut l = TauLucasSequence::new();
        for i in 0..k - 1 {
            l = l.next();
            println!("U_{:?} = {:?}, U_{:?} = {:?}", i + 1, l.u0, i + 2, l.u1);
        }
        let uk_inv = l.u1.inv_mod_pow_k(k);
        let hk = (2 * l.u0 * uk_inv).modulos(base_modulus);

        // Verify tau^k â‰¡ 0 mod (tau^2 - hk * tau + 2)
        let tau = Tau::default();
        let tau_w = tau.pow(k);
        assert_eq!(
            (tau_w.value().a0 + tau_w.value().a1 * hk).modulos(base_modulus),
            0
        );
    }
}
